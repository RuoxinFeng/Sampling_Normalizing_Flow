#
# Copyright (C) 2024, Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
#


import contextlib
from dataclasses import dataclass
from typing import Dict, List, Literal, Optional, Set

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from tools.comparison_tools.divergence_metrics import empirical_js_divergence, ks_test
from tools.general_utility.helpers import display_dataframe, display_markdown, print_and_align, read_and_verify_csv_data
from tools.plot_tools.plot_tools import plot_ks_test_statistic
from tools.remove_invalid_sessions.remove_invalid_sessions import (
    InvalidSessionsSpec,
    TotalFailureInfo,
    remove_invalid_sessions,
)


@dataclass
class Whiskers:
    """A wrapper containing information about the whisker ends of a box plots."""

    lower_whisker: float
    upper_whisker: float


class DatasetComparison:
    """Compare two iterations of a dataset to decide whether a model update is necessary.

    Parameters
    ----------
    path_new_data : str
        The relative path to the new dataset.
    path_old_data : str
        The relative path to the old dataset.
    srs : SRS
        The SRS to be used to remove invalid sessions from the datasets.
    sensor_names : List[str]
        The sensor names to be used to remove invalid sessions from the datasets.
    header_lines_new_data : int or None, optional
        The number of header lines that need to be skipped when reading the new data file.
        If the file was generated by IFAT, this parameter does not need to be provided.
    header_lines_old_data : int or None, optional
        The number of header lines that need to be skipped when reading the old data file.
        If the file was generated by IFAT, this parameter does not need to be provided.
    name_new_data : str, optional
        A name for the new data. The tool will use this name to refer to the new data in plots.
    name_old_data : str, optional
        A name for the old data. The tool will use this name to refer to the old data in plots.
    """

    _session_id_column_name = "session_id"

    def __init__(
        self,
        path_new_data: str,
        path_old_data: str,
        invalid_sessions_spec: InvalidSessionsSpec,
        *,
        header_lines_new_data: Optional[int] = None,
        header_lines_old_data: Optional[int] = None,
        name_new_data: str = "New data",
        name_old_data: str = "Old data",
    ) -> None:
        with contextlib.redirect_stdout(None):
            self._new_data, self._total_failure_info_new = remove_invalid_sessions(
                df=read_and_verify_csv_data(path=path_new_data, header_lines=header_lines_new_data).df,
                spec=invalid_sessions_spec,
            )
            self._old_data, self._total_failure_info_old = remove_invalid_sessions(
                df=read_and_verify_csv_data(path=path_old_data, header_lines=header_lines_old_data).df,
                spec=invalid_sessions_spec,
            )
        self._name_new_data = name_new_data
        self._name_old_data = name_old_data

    @property
    def columns_new_data(self) -> List[str]:
        """List[str] : The names of the columns in the new data set."""
        return self._new_data.columns.to_list()

    @property
    def columns_old_data(self) -> List[str]:
        """List[str] : The names of the columns in the old data set."""
        return self._old_data.columns.to_list()

    def full_analysis(
        self,
        column_name: str,
        *,
        plot_width: int = 500,
        plot_height: int = 500,
        nbins_for_histograms: int = 500,
        threshold_for_changes: float = 0.0,
        exclude_missing_sessions: bool = False,
    ) -> None:
        """Displays all analysis information and plots of a specified column (i.e. runs all methods of DatasetComparison).

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.
        plot_width : int, optional
            The desired width of the generated box plot.
        plot_height : int, optional
            The desired height of the generated box plot.
        n_bins_for_histograms : int, optional
            The number of bins to be used to calculate the Jensen-Shannon divergence.
        threshold_for_changes : float, optional
            The threshold value for changes so that a session will be considered as having a significant change.
            All sessions whose value has changed more than that will be printed.
        exclude_missing_sessions : bool, optional
            Whether sessions that are missing in one dataset should not be displayed as sessions with changes.

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self.summarize(column_name)
        self.compare_box_plots(column_name, width=plot_width, height=plot_height)
        self.compare_divergence_metrics(column_name, nbins=nbins_for_histograms)
        self.compare_outliers(column_name)
        self.sessions_with_changes(
            column_name, threshold=threshold_for_changes, exclude_missing_sessions=exclude_missing_sessions
        )

    def summarize(self, column_name: str) -> None:
        """Displays key statistics of a specified column.

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self._verify_column_exists(column_name)
        display_markdown(f"Summary of column {column_name}", font_size=16)
        display_dataframe(
            pd.DataFrame(
                {
                    self._name_new_data: self._get_single_summary(
                        column=self._new_data[column_name],
                        session_id_column=self._new_data[self._session_id_column_name],
                        total_failure_info=self._total_failure_info_new,
                    ),
                    self._name_old_data: self._get_single_summary(
                        column=self._old_data[column_name],
                        session_id_column=self._old_data[self._session_id_column_name],
                        total_failure_info=self._total_failure_info_old,
                    ),
                }
            ),
            display_index=True,
        )

    def _get_single_summary(
        self, column: pd.Series, session_id_column: pd.Series, total_failure_info: TotalFailureInfo
    ) -> Dict[str, float]:
        mean = column.mean()
        std = column.std()
        nr_outside_std = column.where(np.abs(column - mean) > std).count()
        return {
            "Total number of sessions": column.size,
            "Total failure sessions": total_failure_info.observed_total_failures,
            "Posterior total failure probability": total_failure_info.posterior_total_failure_probability,
            "Mean": mean,
            "Std": std,
            "Min": column.min(),
            "Max": column.max(),
            "Values outside std": nr_outside_std,
            "Outliers (outside whisker)": len(self._get_outliers(column, session_id_column)),
        }

    def _get_outliers(self, column: pd.Series, session_id_column: pd.Series) -> Set[str]:
        whisker_ends = self._get_whisker_ends(column)
        return set(session_id_column.where(column < whisker_ends.lower_whisker).dropna()) | set(
            session_id_column.where(column > whisker_ends.upper_whisker).dropna()
        )

    def _get_whisker_ends(self, column: pd.Series) -> Whiskers:
        q1 = column.quantile(0.25)
        q3 = column.quantile(0.75)
        iqr = q3 - q1
        return Whiskers(
            lower_whisker=column.where(column > q1 - 1.5 * iqr).min(),
            upper_whisker=column.where(column < q3 + 1.5 * iqr).max(),
        )

    def compare_box_plots(self, column_name: str, *, width: int = 500, height: int = 500) -> None:
        """Displays box plots of a specified column.

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.
        width : int, optional
            The desired width of the generated plot.
        height : int, optional
            The desired height of the generated plot.

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self._verify_column_exists(column_name)
        display_markdown(f"Box plots of {column_name}", font_size=16)
        fig = go.Figure()
        fig.update_layout(
            width=width,
            height=height,
        )
        fig.add_trace(
            go.Box(
                y=self._old_data[column_name].to_list(),
                marker_color="royalblue",
                boxmean="sd",
                name=self._name_old_data,
            )
        )
        fig.add_trace(
            go.Box(y=self._new_data[column_name].to_list(), marker_color="teal", boxmean="sd", name=self._name_new_data)
        )
        fig.show()

    def compare_divergence_metrics(
        self, column_name: str, *, nbins: int = 500, plot: Literal["cdf", "hist", "both"] = "cdf"
    ) -> None:
        """Displays divergence metrics and the cdf or histogram of a specified column.

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.
        nbins : int, optional
            The number of bins to be used to plot the histograms and calculate the Jensen-Shannon divergence.
        plot : "cdf", "hist" or both, optional
            The type of plot to be generated (cumulative distribution function, histogram or both).

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self._verify_column_exists(column_name)
        if plot not in ["cdf", "hist", "both"]:
            raise ValueError(f"Unknown value for 'plot': {plot}. Allowed values: ['cdf', 'hist', 'both]")

        display_markdown(f"Divergence metrics of {column_name}", font_size=16)
        new_column = self._new_data[column_name]
        old_column = self._old_data[column_name]
        ks_result = ks_test(new_column, old_column)
        print(f"Divergence metrics for {column_name}:")
        print(f"Jensen-Shannon Divergence: {empirical_js_divergence(new_column,old_column, nbins=nbins)}")
        print(f"Kullback-Leibler Divergence: {ks_result.statistic}")

        if plot in ["cdf", "both"]:
            plot_ks_test_statistic(
                data=(new_column, old_column),
                names=(self._name_new_data, self._name_old_data),
                ks_result=ks_result,
                title=f"CDFs and Kolmogorov- Smirnov test result of {column_name}",
                xlabel=column_name,
            )
        if plot in ["hist", "both"]:
            fig = px.histogram(
                pd.DataFrame({self._name_new_data: new_column, self._name_old_data: old_column}),
                nbins=nbins,
                barmode="overlay",
            )
            fig.update_xaxes(title_text=column_name)
            fig.update_layout(title={"text": f"Histograms of {column_name}", "x": 0.5, "xanchor": "center"})
            fig.show()

    def compare_outliers(self, column_name: str) -> None:
        """Displays an outlier comparison (outliers are sessions with values outside the whiskers of the box plot)
        of a specified column.

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self._verify_column_exists(column_name)
        display_markdown(f"Outlier comparison of {column_name}", font_size=16)
        new_column = self._new_data[column_name]
        old_column = self._old_data[column_name]

        new_outliers = self._get_outliers(new_column, session_id_column=self._new_data[self._session_id_column_name])
        old_outliers = self._get_outliers(old_column, session_id_column=self._old_data[self._session_id_column_name])
        outliers_both = new_outliers & old_outliers
        outliers_only_new = new_outliers - old_outliers
        outliers_only_old = old_outliers - new_outliers

        lines_to_print = {
            "Outliers in both datasets": outliers_both or "",
            f"Outliers only in {self._name_new_data}": outliers_only_new or "",
            f"Outliers only in {self._name_old_data}": outliers_only_old or "",
        }
        print_and_align(lines_to_print)

    def sessions_with_changes(
        self, column_name: str, *, threshold: float = 0.0, exclude_missing_sessions: bool = False
    ) -> None:
        """Displays all sessions that have changes bigger than a threshold in a specified column.

        Parameters
        ----------
        column_name : str
            The name of the column to be analyzed.
        threshold : float, optional
            The threshold value for changes so that a session will be considered as having a significant change.
            All sessions whose value has changed more than that will be printed.
        exclude_missing_sessions : bool, optional
            Whether sessions that are missing in one dataset should not be displayed.

        Raises
        ------
        ValueError
            If the `column_name` is missing in one of the data sets.
        """
        self._verify_column_exists(column_name)
        display_markdown(f"Sessions with changes bigger than {threshold} in {column_name}", font_size=16)

        comparison_df = pd.merge(
            self._new_data, self._old_data, on=self._session_id_column_name, suffixes=["_new", "_old"], how="outer"
        )
        column_name_new_data = column_name + "_new"
        column_name_old_data = column_name + "_old"
        comparison_df["difference"] = (comparison_df[column_name_new_data] - comparison_df[column_name_old_data]).abs()
        changed_sessions = (
            comparison_df[self._session_id_column_name].where(comparison_df["difference"] > threshold).dropna()
        )
        if not exclude_missing_sessions:
            changed_sessions = pd.concat(
                [
                    changed_sessions,
                    comparison_df[self._session_id_column_name].where(comparison_df["difference"].isna()).dropna(),
                ]
            )

        self._print_changed_sessions(
            changed_sessions, comparison_df, column_name_old_data, column_name_new_data, threshold
        )

    def _print_changed_sessions(
        self,
        changed_sessions: str,
        comparison_df: pd.DataFrame,
        column_name_old_data: str,
        column_name_new_data: str,
        threshold: float,
    ) -> None:
        lines_to_print = {}
        for session_id in changed_sessions:
            old_value = comparison_df.loc[
                comparison_df[self._session_id_column_name] == session_id, column_name_old_data
            ].iloc[0]
            new_value = comparison_df.loc[
                comparison_df[self._session_id_column_name] == session_id, column_name_new_data
            ].iloc[0]
            lines_to_print[session_id] = f"Changed from {old_value} to {new_value}"

        if lines_to_print:
            print_and_align(lines_to_print)
        else:
            print(f"There were no sessions whose values have changed by more than {threshold}.")

    def _verify_column_exists(self, column_name: str) -> None:
        if column_name not in self._new_data:
            raise ValueError(f"Column {column_name} does not exist in {self._name_new_data}.")
        if column_name not in self._old_data:
            raise ValueError(f"Column {column_name} does not exist in {self._name_old_data}.")
